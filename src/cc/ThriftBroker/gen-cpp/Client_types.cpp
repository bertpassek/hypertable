/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Client_types.h"

#include <algorithm>

namespace Hypertable { namespace ThriftGen {

int _kColumnPredicateOperationValues[] = {
  ColumnPredicateOperation::EXACT_MATCH,
  ColumnPredicateOperation::PREFIX_MATCH,
  ColumnPredicateOperation::REGEX_MATCH,
  ColumnPredicateOperation::VALUE_MATCH,
  ColumnPredicateOperation::QUALIFIER_EXACT_MATCH,
  ColumnPredicateOperation::QUALIFIER_PREFIX_MATCH,
  ColumnPredicateOperation::QUALIFIER_REGEX_MATCH,
  ColumnPredicateOperation::QUALIFIER_MATCH
};
const char* _kColumnPredicateOperationNames[] = {
  "EXACT_MATCH",
  "PREFIX_MATCH",
  "REGEX_MATCH",
  "VALUE_MATCH",
  "QUALIFIER_EXACT_MATCH",
  "QUALIFIER_PREFIX_MATCH",
  "QUALIFIER_REGEX_MATCH",
  "QUALIFIER_MATCH"
};
const std::map<int, const char*> _ColumnPredicateOperation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kColumnPredicateOperationValues, _kColumnPredicateOperationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kKeyFlagValues[] = {
  KeyFlag::DELETE_ROW,
  KeyFlag::DELETE_CF,
  KeyFlag::DELETE_CELL,
  KeyFlag::DELETE_CELL_VERSION,
  KeyFlag::INSERT
};
const char* _kKeyFlagNames[] = {
  "DELETE_ROW",
  "DELETE_CF",
  "DELETE_CELL",
  "DELETE_CELL_VERSION",
  "INSERT"
};
const std::map<int, const char*> _KeyFlag_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kKeyFlagValues, _kKeyFlagNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMutatorFlagValues[] = {
  MutatorFlag::NO_LOG_SYNC,
  MutatorFlag::IGNORE_UNKNOWN_CFS
};
const char* _kMutatorFlagNames[] = {
  "NO_LOG_SYNC",
  "IGNORE_UNKNOWN_CFS"
};
const std::map<int, const char*> _MutatorFlag_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kMutatorFlagValues, _kMutatorFlagNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* RowInterval::ascii_fingerprint = "E1A4BCD94F003EFF8636F1C98591705A";
const uint8_t RowInterval::binary_fingerprint[16] = {0xE1,0xA4,0xBC,0xD9,0x4F,0x00,0x3E,0xFF,0x86,0x36,0xF1,0xC9,0x85,0x91,0x70,0x5A};

uint32_t RowInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_row);
          this->__isset.start_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->start_inclusive);
          this->__isset.start_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_row);
          this->__isset.end_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->end_inclusive);
          this->__isset.end_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RowInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RowInterval");

  if (this->__isset.start_row) {
    xfer += oprot->writeFieldBegin("start_row", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->start_row);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start_inclusive) {
    xfer += oprot->writeFieldBegin("start_inclusive", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->start_inclusive);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_row) {
    xfer += oprot->writeFieldBegin("end_row", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->end_row);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_inclusive) {
    xfer += oprot->writeFieldBegin("end_inclusive", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->end_inclusive);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RowInterval &a, RowInterval &b) {
  using ::std::swap;
  swap(a.start_row, b.start_row);
  swap(a.start_inclusive, b.start_inclusive);
  swap(a.end_row, b.end_row);
  swap(a.end_inclusive, b.end_inclusive);
  swap(a.__isset, b.__isset);
}

const char* CellInterval::ascii_fingerprint = "D8C6D6FAE68BF8B6CA0EB2AB01E82C6C";
const uint8_t CellInterval::binary_fingerprint[16] = {0xD8,0xC6,0xD6,0xFA,0xE6,0x8B,0xF8,0xB6,0xCA,0x0E,0xB2,0xAB,0x01,0xE8,0x2C,0x6C};

uint32_t CellInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_row);
          this->__isset.start_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_column);
          this->__isset.start_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->start_inclusive);
          this->__isset.start_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_row);
          this->__isset.end_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_column);
          this->__isset.end_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->end_inclusive);
          this->__isset.end_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CellInterval");

  if (this->__isset.start_row) {
    xfer += oprot->writeFieldBegin("start_row", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->start_row);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start_column) {
    xfer += oprot->writeFieldBegin("start_column", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->start_column);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start_inclusive) {
    xfer += oprot->writeFieldBegin("start_inclusive", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->start_inclusive);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_row) {
    xfer += oprot->writeFieldBegin("end_row", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->end_row);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_column) {
    xfer += oprot->writeFieldBegin("end_column", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->end_column);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_inclusive) {
    xfer += oprot->writeFieldBegin("end_inclusive", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->end_inclusive);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellInterval &a, CellInterval &b) {
  using ::std::swap;
  swap(a.start_row, b.start_row);
  swap(a.start_column, b.start_column);
  swap(a.start_inclusive, b.start_inclusive);
  swap(a.end_row, b.end_row);
  swap(a.end_column, b.end_column);
  swap(a.end_inclusive, b.end_inclusive);
  swap(a.__isset, b.__isset);
}

const char* ColumnPredicate::ascii_fingerprint = "C0D24FEC9006AF59BF63864BF9F94F59";
const uint8_t ColumnPredicate::binary_fingerprint[16] = {0xC0,0xD2,0x4F,0xEC,0x90,0x06,0xAF,0x59,0xBF,0x63,0x86,0x4B,0xF9,0xF9,0x4F,0x59};

uint32_t ColumnPredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_family);
          this->__isset.column_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_qualifier);
          this->__isset.column_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->operation);
          this->__isset.operation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnPredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnPredicate");

  if (this->__isset.column_family) {
    xfer += oprot->writeFieldBegin("column_family", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->column_family);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_qualifier) {
    xfer += oprot->writeFieldBegin("column_qualifier", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->column_qualifier);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("operation", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->operation);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnPredicate &a, ColumnPredicate &b) {
  using ::std::swap;
  swap(a.column_family, b.column_family);
  swap(a.column_qualifier, b.column_qualifier);
  swap(a.operation, b.operation);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* ScanSpec::ascii_fingerprint = "E832747BA3A08125D187174C984AAD63";
const uint8_t ScanSpec::binary_fingerprint[16] = {0xE8,0x32,0x74,0x7B,0xA3,0xA0,0x81,0x25,0xD1,0x87,0x17,0x4C,0x98,0x4A,0xAD,0x63};

uint32_t ScanSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_intervals.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->row_intervals.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->row_intervals[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cell_intervals.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->cell_intervals.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += this->cell_intervals[_i9].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cell_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->return_deletes);
          this->__isset.return_deletes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->versions);
          this->__isset.versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->row_limit);
          this->__isset.row_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_time);
          this->__isset.end_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->columns.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += iprot->readString(this->columns[_i14]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->keys_only);
          this->__isset.keys_only = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_limit);
          this->__isset.cell_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_limit_per_family);
          this->__isset.cell_limit_per_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->row_regexp);
          this->__isset.row_regexp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value_regexp);
          this->__isset.value_regexp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->scan_and_filter_rows);
          this->__isset.scan_and_filter_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->row_offset);
          this->__isset.row_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_offset);
          this->__isset.cell_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_predicates.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            xfer += iprot->readListBegin(_etype18, _size15);
            this->column_predicates.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              xfer += this->column_predicates[_i19].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_predicates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->do_not_cache);
          this->__isset.do_not_cache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->and_column_predicates);
          this->__isset.and_column_predicates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScanSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ScanSpec");

  if (this->__isset.row_intervals) {
    xfer += oprot->writeFieldBegin("row_intervals", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_intervals.size()));
      std::vector<RowInterval> ::const_iterator _iter20;
      for (_iter20 = this->row_intervals.begin(); _iter20 != this->row_intervals.end(); ++_iter20)
      {
        xfer += (*_iter20).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_intervals) {
    xfer += oprot->writeFieldBegin("cell_intervals", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cell_intervals.size()));
      std::vector<CellInterval> ::const_iterator _iter21;
      for (_iter21 = this->cell_intervals.begin(); _iter21 != this->cell_intervals.end(); ++_iter21)
      {
        xfer += (*_iter21).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.return_deletes) {
    xfer += oprot->writeFieldBegin("return_deletes", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->return_deletes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.versions) {
    xfer += oprot->writeFieldBegin("versions", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_limit) {
    xfer += oprot->writeFieldBegin("row_limit", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->row_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start_time) {
    xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->start_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_time) {
    xfer += oprot->writeFieldBegin("end_time", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->end_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
      std::vector<std::string> ::const_iterator _iter22;
      for (_iter22 = this->columns.begin(); _iter22 != this->columns.end(); ++_iter22)
      {
        xfer += oprot->writeString((*_iter22));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.keys_only) {
    xfer += oprot->writeFieldBegin("keys_only", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->keys_only);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_limit_per_family) {
    xfer += oprot->writeFieldBegin("cell_limit_per_family", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->cell_limit_per_family);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_regexp) {
    xfer += oprot->writeFieldBegin("row_regexp", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->row_regexp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value_regexp) {
    xfer += oprot->writeFieldBegin("value_regexp", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->value_regexp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scan_and_filter_rows) {
    xfer += oprot->writeFieldBegin("scan_and_filter_rows", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->scan_and_filter_rows);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_limit) {
    xfer += oprot->writeFieldBegin("cell_limit", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(this->cell_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_offset) {
    xfer += oprot->writeFieldBegin("row_offset", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->row_offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_offset) {
    xfer += oprot->writeFieldBegin("cell_offset", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->cell_offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_predicates) {
    xfer += oprot->writeFieldBegin("column_predicates", ::apache::thrift::protocol::T_LIST, 17);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_predicates.size()));
      std::vector<ColumnPredicate> ::const_iterator _iter23;
      for (_iter23 = this->column_predicates.begin(); _iter23 != this->column_predicates.end(); ++_iter23)
      {
        xfer += (*_iter23).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.do_not_cache) {
    xfer += oprot->writeFieldBegin("do_not_cache", ::apache::thrift::protocol::T_BOOL, 18);
    xfer += oprot->writeBool(this->do_not_cache);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.and_column_predicates) {
    xfer += oprot->writeFieldBegin("and_column_predicates", ::apache::thrift::protocol::T_BOOL, 19);
    xfer += oprot->writeBool(this->and_column_predicates);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScanSpec &a, ScanSpec &b) {
  using ::std::swap;
  swap(a.row_intervals, b.row_intervals);
  swap(a.cell_intervals, b.cell_intervals);
  swap(a.return_deletes, b.return_deletes);
  swap(a.versions, b.versions);
  swap(a.row_limit, b.row_limit);
  swap(a.start_time, b.start_time);
  swap(a.end_time, b.end_time);
  swap(a.columns, b.columns);
  swap(a.keys_only, b.keys_only);
  swap(a.cell_limit, b.cell_limit);
  swap(a.cell_limit_per_family, b.cell_limit_per_family);
  swap(a.row_regexp, b.row_regexp);
  swap(a.value_regexp, b.value_regexp);
  swap(a.scan_and_filter_rows, b.scan_and_filter_rows);
  swap(a.row_offset, b.row_offset);
  swap(a.cell_offset, b.cell_offset);
  swap(a.column_predicates, b.column_predicates);
  swap(a.do_not_cache, b.do_not_cache);
  swap(a.and_column_predicates, b.and_column_predicates);
  swap(a.__isset, b.__isset);
}

const char* Key::ascii_fingerprint = "17134A3D4B5435B7D4FA71A5B3905382";
const uint8_t Key::binary_fingerprint[16] = {0x17,0x13,0x4A,0x3D,0x4B,0x54,0x35,0xB7,0xD4,0xFA,0x71,0xA5,0xB3,0x90,0x53,0x82};

uint32_t Key::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_family);
          this->__isset.column_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_qualifier);
          this->__isset.column_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast24;
          xfer += iprot->readI32(ecast24);
          this->flag = (KeyFlag::type)ecast24;
          this->__isset.flag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Key::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Key");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_family", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->column_family);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_qualifier", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_qualifier);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.revision) {
    xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->revision);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("flag", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->flag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Key &a, Key &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.column_family, b.column_family);
  swap(a.column_qualifier, b.column_qualifier);
  swap(a.timestamp, b.timestamp);
  swap(a.revision, b.revision);
  swap(a.flag, b.flag);
  swap(a.__isset, b.__isset);
}

const char* MutateSpec::ascii_fingerprint = "28C2ECC89260BADB9C70330FBF47BFA8";
const uint8_t MutateSpec::binary_fingerprint[16] = {0x28,0xC2,0xEC,0xC8,0x92,0x60,0xBA,0xDB,0x9C,0x70,0x33,0x0F,0xBF,0x47,0xBF,0xA8};

uint32_t MutateSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_appname = false;
  bool isset_flush_interval = false;
  bool isset_flags = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appname);
          isset_appname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->flush_interval);
          isset_flush_interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->flags);
          isset_flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_appname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_flush_interval)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_flags)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MutateSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MutateSpec");

  xfer += oprot->writeFieldBegin("appname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->appname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flush_interval", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->flush_interval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->flags);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MutateSpec &a, MutateSpec &b) {
  using ::std::swap;
  swap(a.appname, b.appname);
  swap(a.flush_interval, b.flush_interval);
  swap(a.flags, b.flags);
}

const char* Cell::ascii_fingerprint = "DC051ACCFBB8C1A7B6D15A530DEBC267";
const uint8_t Cell::binary_fingerprint[16] = {0xDC,0x05,0x1A,0xCC,0xFB,0xB8,0xC1,0xA7,0xB6,0xD1,0x5A,0x53,0x0D,0xEB,0xC2,0x67};

uint32_t Cell::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->key.read(iprot);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cell");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->key.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cell &a, Cell &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* Result::ascii_fingerprint = "3961071AF9F0CD494C023BDE4BE15710";
const uint8_t Result::binary_fingerprint[16] = {0x39,0x61,0x07,0x1A,0xF9,0xF0,0xCD,0x49,0x4C,0x02,0x3B,0xDE,0x4B,0xE1,0x57,0x10};

uint32_t Result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_empty = false;
  bool isset_id = false;
  bool isset_is_scan = false;
  bool isset_is_error = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_empty);
          isset_is_empty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_scan);
          isset_is_scan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          isset_is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->cells.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += this->cells[_i29].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_empty)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_scan)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_error)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Result");

  xfer += oprot->writeFieldBegin("is_empty", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_empty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_scan", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_scan);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_error);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error_msg) {
    xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->error_msg);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cells) {
    xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
      std::vector<Cell> ::const_iterator _iter30;
      for (_iter30 = this->cells.begin(); _iter30 != this->cells.end(); ++_iter30)
      {
        xfer += (*_iter30).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Result &a, Result &b) {
  using ::std::swap;
  swap(a.is_empty, b.is_empty);
  swap(a.id, b.id);
  swap(a.is_scan, b.is_scan);
  swap(a.is_error, b.is_error);
  swap(a.error, b.error);
  swap(a.error_msg, b.error_msg);
  swap(a.cells, b.cells);
  swap(a.__isset, b.__isset);
}

const char* ResultAsArrays::ascii_fingerprint = "E386C86852D0BFBEDC152386E212771F";
const uint8_t ResultAsArrays::binary_fingerprint[16] = {0xE3,0x86,0xC8,0x68,0x52,0xD0,0xBF,0xBE,0xDC,0x15,0x23,0x86,0xE2,0x12,0x77,0x1F};

uint32_t ResultAsArrays::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_empty = false;
  bool isset_id = false;
  bool isset_is_scan = false;
  bool isset_is_error = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_empty);
          isset_is_empty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_scan);
          isset_is_scan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          isset_is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->cells.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              {
                this->cells[_i35].clear();
                uint32_t _size36;
                ::apache::thrift::protocol::TType _etype39;
                xfer += iprot->readListBegin(_etype39, _size36);
                this->cells[_i35].resize(_size36);
                uint32_t _i40;
                for (_i40 = 0; _i40 < _size36; ++_i40)
                {
                  xfer += iprot->readString(this->cells[_i35][_i40]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_empty)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_scan)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_error)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResultAsArrays::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultAsArrays");

  xfer += oprot->writeFieldBegin("is_empty", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_empty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_scan", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_scan);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_error);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error_msg) {
    xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->error_msg);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cells) {
    xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->cells.size()));
      std::vector<CellAsArray> ::const_iterator _iter41;
      for (_iter41 = this->cells.begin(); _iter41 != this->cells.end(); ++_iter41)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter41).size()));
          std::vector<std::string> ::const_iterator _iter42;
          for (_iter42 = (*_iter41).begin(); _iter42 != (*_iter41).end(); ++_iter42)
          {
            xfer += oprot->writeString((*_iter42));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResultAsArrays &a, ResultAsArrays &b) {
  using ::std::swap;
  swap(a.is_empty, b.is_empty);
  swap(a.id, b.id);
  swap(a.is_scan, b.is_scan);
  swap(a.is_error, b.is_error);
  swap(a.error, b.error);
  swap(a.error_msg, b.error_msg);
  swap(a.cells, b.cells);
  swap(a.__isset, b.__isset);
}

const char* ResultSerialized::ascii_fingerprint = "8D7BAC5AE63452BB4EA65AE73E2331A7";
const uint8_t ResultSerialized::binary_fingerprint[16] = {0x8D,0x7B,0xAC,0x5A,0xE6,0x34,0x52,0xBB,0x4E,0xA6,0x5A,0xE7,0x3E,0x23,0x31,0xA7};

uint32_t ResultSerialized::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_empty = false;
  bool isset_id = false;
  bool isset_is_scan = false;
  bool isset_is_error = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_empty);
          isset_is_empty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_scan);
          isset_is_scan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          isset_is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->cells);
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_empty)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_scan)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_error)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResultSerialized::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultSerialized");

  xfer += oprot->writeFieldBegin("is_empty", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_empty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_scan", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_scan);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_error);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error_msg) {
    xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->error_msg);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cells) {
    xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeBinary(this->cells);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResultSerialized &a, ResultSerialized &b) {
  using ::std::swap;
  swap(a.is_empty, b.is_empty);
  swap(a.id, b.id);
  swap(a.is_scan, b.is_scan);
  swap(a.is_error, b.is_error);
  swap(a.error, b.error);
  swap(a.error_msg, b.error_msg);
  swap(a.cells, b.cells);
  swap(a.__isset, b.__isset);
}

const char* NamespaceListing::ascii_fingerprint = "7D61C9AA00102AB4D8F72A1DA58297DC";
const uint8_t NamespaceListing::binary_fingerprint[16] = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};

uint32_t NamespaceListing::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_is_namespace = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_namespace);
          isset_is_namespace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_namespace)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NamespaceListing::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NamespaceListing");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_namespace", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_namespace);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NamespaceListing &a, NamespaceListing &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.is_namespace, b.is_namespace);
}

const char* TableSplit::ascii_fingerprint = "62D6903A20E658BF9EEF263D3451F763";
const uint8_t TableSplit::binary_fingerprint[16] = {0x62,0xD6,0x90,0x3A,0x20,0xE6,0x58,0xBF,0x9E,0xEF,0x26,0x3D,0x34,0x51,0xF7,0x63};

uint32_t TableSplit::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_row);
          this->__isset.start_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_row);
          this->__isset.end_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip_address);
          this->__isset.ip_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          this->__isset.hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TableSplit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TableSplit");

  if (this->__isset.start_row) {
    xfer += oprot->writeFieldBegin("start_row", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->start_row);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_row) {
    xfer += oprot->writeFieldBegin("end_row", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->end_row);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_address) {
    xfer += oprot->writeFieldBegin("ip_address", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->ip_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hostname) {
    xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->hostname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableSplit &a, TableSplit &b) {
  using ::std::swap;
  swap(a.start_row, b.start_row);
  swap(a.end_row, b.end_row);
  swap(a.location, b.location);
  swap(a.ip_address, b.ip_address);
  swap(a.hostname, b.hostname);
  swap(a.__isset, b.__isset);
}

const char* ColumnFamilyOptions::ascii_fingerprint = "ACE5CDEF5DC5021F5001821D7845FB8C";
const uint8_t ColumnFamilyOptions::binary_fingerprint[16] = {0xAC,0xE5,0xCD,0xEF,0x5D,0xC5,0x02,0x1F,0x50,0x01,0x82,0x1D,0x78,0x45,0xFB,0x8C};

uint32_t ColumnFamilyOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_versions);
          this->__isset.max_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ttl);
          this->__isset.ttl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->time_order_desc);
          this->__isset.time_order_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->counter);
          this->__isset.counter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnFamilyOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnFamilyOptions");

  if (this->__isset.max_versions) {
    xfer += oprot->writeFieldBegin("max_versions", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->max_versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ttl) {
    xfer += oprot->writeFieldBegin("ttl", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->ttl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.time_order_desc) {
    xfer += oprot->writeFieldBegin("time_order_desc", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->time_order_desc);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.counter) {
    xfer += oprot->writeFieldBegin("counter", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->counter);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnFamilyOptions &a, ColumnFamilyOptions &b) {
  using ::std::swap;
  swap(a.max_versions, b.max_versions);
  swap(a.ttl, b.ttl);
  swap(a.time_order_desc, b.time_order_desc);
  swap(a.counter, b.counter);
  swap(a.__isset, b.__isset);
}

const char* ColumnFamilySpec::ascii_fingerprint = "42BC359FA17CBF00292D6912CDDB5034";
const uint8_t ColumnFamilySpec::binary_fingerprint[16] = {0x42,0xBC,0x35,0x9F,0xA1,0x7C,0xBF,0x00,0x29,0x2D,0x69,0x12,0xCD,0xDB,0x50,0x34};

uint32_t ColumnFamilySpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->access_group);
          this->__isset.access_group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->deleted);
          this->__isset.deleted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->generation);
          this->__isset.generation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->value_index);
          this->__isset.value_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->qualifier_index);
          this->__isset.qualifier_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnFamilySpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnFamilySpec");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("access_group", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->access_group);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deleted", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->deleted);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.generation) {
    xfer += oprot->writeFieldBegin("generation", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->generation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("value_index", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->value_index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qualifier_index", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->qualifier_index);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->options.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnFamilySpec &a, ColumnFamilySpec &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.access_group, b.access_group);
  swap(a.deleted, b.deleted);
  swap(a.generation, b.generation);
  swap(a.id, b.id);
  swap(a.value_index, b.value_index);
  swap(a.qualifier_index, b.qualifier_index);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

const char* AccessGroupOptions::ascii_fingerprint = "4346BA357564A572D7812C869630F2AF";
const uint8_t AccessGroupOptions::binary_fingerprint[16] = {0x43,0x46,0xBA,0x35,0x75,0x64,0xA5,0x72,0xD7,0x81,0x2C,0x86,0x96,0x30,0xF2,0xAF};

uint32_t AccessGroupOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->replication);
          this->__isset.replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blocksize);
          this->__isset.blocksize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->compressor);
          this->__isset.compressor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bloom_filter);
          this->__isset.bloom_filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->in_memory);
          this->__isset.in_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccessGroupOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccessGroupOptions");

  if (this->__isset.replication) {
    xfer += oprot->writeFieldBegin("replication", ::apache::thrift::protocol::T_I16, 1);
    xfer += oprot->writeI16(this->replication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blocksize) {
    xfer += oprot->writeFieldBegin("blocksize", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->blocksize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressor) {
    xfer += oprot->writeFieldBegin("compressor", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->compressor);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bloom_filter) {
    xfer += oprot->writeFieldBegin("bloom_filter", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->bloom_filter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.in_memory) {
    xfer += oprot->writeFieldBegin("in_memory", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->in_memory);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccessGroupOptions &a, AccessGroupOptions &b) {
  using ::std::swap;
  swap(a.replication, b.replication);
  swap(a.blocksize, b.blocksize);
  swap(a.compressor, b.compressor);
  swap(a.bloom_filter, b.bloom_filter);
  swap(a.in_memory, b.in_memory);
  swap(a.__isset, b.__isset);
}

const char* AccessGroupSpec::ascii_fingerprint = "45567B8B7814C24C13725F0ED4F36F3B";
const uint8_t AccessGroupSpec::binary_fingerprint[16] = {0x45,0x56,0x7B,0x8B,0x78,0x14,0xC2,0x4C,0x13,0x72,0x5F,0x0E,0xD4,0xF3,0x6F,0x3B};

uint32_t AccessGroupSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->generation);
          this->__isset.generation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->defaults.read(iprot);
          this->__isset.defaults = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccessGroupSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccessGroupSpec");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.generation) {
    xfer += oprot->writeFieldBegin("generation", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->generation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->options.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaults) {
    xfer += oprot->writeFieldBegin("defaults", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->defaults.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccessGroupSpec &a, AccessGroupSpec &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.generation, b.generation);
  swap(a.options, b.options);
  swap(a.defaults, b.defaults);
  swap(a.__isset, b.__isset);
}

const char* Schema::ascii_fingerprint = "CE3A6EFB26C0FEE4181164C929D9051B";
const uint8_t Schema::binary_fingerprint[16] = {0xCE,0x3A,0x6E,0xFB,0x26,0xC0,0xFE,0xE4,0x18,0x11,0x64,0xC9,0x29,0xD9,0x05,0x1B};

uint32_t Schema::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->access_groups.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _ktype44;
            ::apache::thrift::protocol::TType _vtype45;
            xfer += iprot->readMapBegin(_ktype44, _vtype45, _size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              std::string _key48;
              xfer += iprot->readString(_key48);
              AccessGroupSpec& _val49 = this->access_groups[_key48];
              xfer += _val49.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.access_groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->column_families.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _ktype51;
            ::apache::thrift::protocol::TType _vtype52;
            xfer += iprot->readMapBegin(_ktype51, _vtype52, _size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              std::string _key55;
              xfer += iprot->readString(_key55);
              ColumnFamilySpec& _val56 = this->column_families[_key55];
              xfer += _val56.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.column_families = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->generation);
          this->__isset.generation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->group_commit_interval);
          this->__isset.group_commit_interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->access_group_defaults.read(iprot);
          this->__isset.access_group_defaults = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column_family_defaults.read(iprot);
          this->__isset.column_family_defaults = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Schema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Schema");

  if (this->__isset.access_groups) {
    xfer += oprot->writeFieldBegin("access_groups", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->access_groups.size()));
      std::map<std::string, AccessGroupSpec> ::const_iterator _iter57;
      for (_iter57 = this->access_groups.begin(); _iter57 != this->access_groups.end(); ++_iter57)
      {
        xfer += oprot->writeString(_iter57->first);
        xfer += _iter57->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_families) {
    xfer += oprot->writeFieldBegin("column_families", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_families.size()));
      std::map<std::string, ColumnFamilySpec> ::const_iterator _iter58;
      for (_iter58 = this->column_families.begin(); _iter58 != this->column_families.end(); ++_iter58)
      {
        xfer += oprot->writeString(_iter58->first);
        xfer += _iter58->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.generation) {
    xfer += oprot->writeFieldBegin("generation", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->generation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group_commit_interval) {
    xfer += oprot->writeFieldBegin("group_commit_interval", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->group_commit_interval);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.access_group_defaults) {
    xfer += oprot->writeFieldBegin("access_group_defaults", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->access_group_defaults.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_family_defaults) {
    xfer += oprot->writeFieldBegin("column_family_defaults", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->column_family_defaults.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Schema &a, Schema &b) {
  using ::std::swap;
  swap(a.access_groups, b.access_groups);
  swap(a.column_families, b.column_families);
  swap(a.generation, b.generation);
  swap(a.version, b.version);
  swap(a.group_commit_interval, b.group_commit_interval);
  swap(a.access_group_defaults, b.access_group_defaults);
  swap(a.column_family_defaults, b.column_family_defaults);
  swap(a.__isset, b.__isset);
}

const char* ClientException::ascii_fingerprint = "3F5FC93B338687BC7235B1AB103F47B3";
const uint8_t ClientException::binary_fingerprint[16] = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

uint32_t ClientException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ClientException");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClientException &a, ClientException &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

}} // namespace
